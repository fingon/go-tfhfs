// Code generated by GREENPACK (github.com/glycerine/greenpack). DO NOT EDIT.

package fs

import (
	"github.com/glycerine/greenpack/msgp"
)

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *BlockSubType) DecodeMsg(dc *msgp.Reader) (err error) {

	{
		var zgensym_83ac265a46b03003_0 byte
		zgensym_83ac265a46b03003_0, err = dc.ReadByte()
		(*z) = BlockSubType(zgensym_83ac265a46b03003_0)
	}
	if err != nil {
		return
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z BlockSubType) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	err = en.WriteByte(byte(z))
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z BlockSubType) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendByte(o, byte(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BlockSubType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *BlockSubType) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	{
		var zgensym_83ac265a46b03003_1 byte
		zgensym_83ac265a46b03003_1, bts, err = nbs.ReadByteBytes(bts)

		if err != nil {
			return
		}
		(*z) = BlockSubType(zgensym_83ac265a46b03003_1)
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z BlockSubType) Msgsize() (s int) {
	s = msgp.ByteSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *InodeMeta) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_83ac265a46b03003_2 uint32
	zgensym_83ac265a46b03003_2, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_83ac265a46b03003_2 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_83ac265a46b03003_2}
		return
	}
	err = z.InodeMetaData.DecodeMsg(dc)
	if err != nil {
		return
	}
	z.Data, err = dc.ReadBytes(z.Data)
	if err != nil {
		return
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *InodeMeta) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return err
	}
	// encodeGen.gBase IDENT

	// record the interface for deduplication
	var dup bool
	dup, err = en.DedupWriteIsDup(z.InodeMetaData)
	if err != nil {
		return
	}
	if !dup {
		err = z.InodeMetaData.EncodeMsg(en)
		if err != nil {
			return
		}
	}
	err = en.WriteBytes(z.Data)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *InodeMeta) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// array header, size 2
	o = append(o, 0x92)
	o, err = z.InodeMetaData.MarshalMsg(o) // not is.iface, gen/marshal.go:243
	if err != nil {
		return
	}
	o = msgp.AppendBytes(o, z.Data)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InodeMeta) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *InodeMeta) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zgensym_83ac265a46b03003_3 uint32
	zgensym_83ac265a46b03003_3, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_83ac265a46b03003_3 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_83ac265a46b03003_3}
		return
	}
	bts, err = z.InodeMetaData.UnmarshalMsg(bts)
	if err != nil {
		return
	}
	if nbs.AlwaysNil || msgp.IsNil(bts) {
		if !nbs.AlwaysNil {
			bts = bts[1:]
		}
		z.Data = z.Data[:0]
	} else {
		z.Data, bts, err = nbs.ReadBytesBytes(bts, z.Data)

		if err != nil {
			return
		}
	}
	if err != nil {
		return
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InodeMeta) Msgsize() (s int) {
	s = 1 + z.InodeMetaData.Msgsize() + msgp.BytesPrefixSize + len(z.Data)
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *InodeMetaData) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_83ac265a46b03003_4 uint32
	zgensym_83ac265a46b03003_4, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_83ac265a46b03003_4 != 10 {
		err = msgp.ArrayError{Wanted: 10, Got: zgensym_83ac265a46b03003_4}
		return
	}
	z.StMode, err = dc.ReadUint32()
	if err != nil {
		return
	}
	z.StRdev, err = dc.ReadUint32()
	if err != nil {
		return
	}
	z.StUid, err = dc.ReadUint32()
	if err != nil {
		return
	}
	z.StGid, err = dc.ReadUint32()
	if err != nil {
		return
	}
	z.StAtimeNs, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.StCtimeNs, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.StMtimeNs, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.StSize, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.StNlink, err = dc.ReadUint32()
	if err != nil {
		return
	}
	z.ParentIno, err = dc.ReadUint64()
	if err != nil {
		return
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *InodeMetaData) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// array header, size 10
	err = en.Append(0x9a)
	if err != nil {
		return err
	}
	err = en.WriteUint32(z.StMode)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.StRdev)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.StUid)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.StGid)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.StAtimeNs)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.StCtimeNs)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.StMtimeNs)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.StSize)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.StNlink)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ParentIno)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *InodeMetaData) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// array header, size 10
	o = append(o, 0x9a)
	o = msgp.AppendUint32(o, z.StMode)
	o = msgp.AppendUint32(o, z.StRdev)
	o = msgp.AppendUint32(o, z.StUid)
	o = msgp.AppendUint32(o, z.StGid)
	o = msgp.AppendUint64(o, z.StAtimeNs)
	o = msgp.AppendUint64(o, z.StCtimeNs)
	o = msgp.AppendUint64(o, z.StMtimeNs)
	o = msgp.AppendUint64(o, z.StSize)
	o = msgp.AppendUint32(o, z.StNlink)
	o = msgp.AppendUint64(o, z.ParentIno)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InodeMetaData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *InodeMetaData) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zgensym_83ac265a46b03003_5 uint32
	zgensym_83ac265a46b03003_5, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_83ac265a46b03003_5 != 10 {
		err = msgp.ArrayError{Wanted: 10, Got: zgensym_83ac265a46b03003_5}
		return
	}
	z.StMode, bts, err = nbs.ReadUint32Bytes(bts)

	if err != nil {
		return
	}
	z.StRdev, bts, err = nbs.ReadUint32Bytes(bts)

	if err != nil {
		return
	}
	z.StUid, bts, err = nbs.ReadUint32Bytes(bts)

	if err != nil {
		return
	}
	z.StGid, bts, err = nbs.ReadUint32Bytes(bts)

	if err != nil {
		return
	}
	z.StAtimeNs, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.StCtimeNs, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.StMtimeNs, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.StSize, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.StNlink, bts, err = nbs.ReadUint32Bytes(bts)

	if err != nil {
		return
	}
	z.ParentIno, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InodeMetaData) Msgsize() (s int) {
	s = 1 + msgp.Uint32Size + msgp.Uint32Size + msgp.Uint32Size + msgp.Uint32Size + msgp.Uint64Size + msgp.Uint64Size + msgp.Uint64Size + msgp.Uint64Size + msgp.Uint32Size + msgp.Uint64Size
	return
}
