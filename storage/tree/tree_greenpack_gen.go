// Code generated by GREENPACK (github.com/glycerine/greenpack). DO NOT EDIT.

package tree

import (
	"github.com/glycerine/greenpack/msgp"
)

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *BlockData) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_1 uint32
	zgensym_f1f62b7068e7cc57_1, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_1 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_1}
		return
	}
	err = z.BlockMetadata.DecodeMsg(dc)
	if err != nil {
		return
	}
	var zgensym_f1f62b7068e7cc57_2 uint32
	zgensym_f1f62b7068e7cc57_2, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Location) >= int(zgensym_f1f62b7068e7cc57_2) {
		z.Location = (z.Location)[:zgensym_f1f62b7068e7cc57_2]
	} else {
		z.Location = make(LocationSlice, zgensym_f1f62b7068e7cc57_2)
	}
	for zgensym_f1f62b7068e7cc57_0 := range z.Location {
		var zgensym_f1f62b7068e7cc57_3 uint32
		zgensym_f1f62b7068e7cc57_3, err = dc.ReadArrayHeader()
		if err != nil {
			return
		}
		if zgensym_f1f62b7068e7cc57_3 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_3}
			return
		}
		z.Location[zgensym_f1f62b7068e7cc57_0].Offset, err = dc.ReadUint64()
		if err != nil {
			return
		}
		z.Location[zgensym_f1f62b7068e7cc57_0].Size, err = dc.ReadUint64()
		if err != nil {
			return
		}
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *BlockData) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return err
	}
	// encodeGen.gBase IDENT

	// record the interface for deduplication
	var dup bool
	dup, err = en.DedupWriteIsDup(z.BlockMetadata)
	if err != nil {
		return
	}
	if !dup {
		err = z.BlockMetadata.EncodeMsg(en)
		if err != nil {
			return
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.Location)))
	if err != nil {
		return
	}
	for zgensym_f1f62b7068e7cc57_0 := range z.Location {
		// array header, size 2
		err = en.Append(0x92)
		if err != nil {
			return err
		}
		err = en.WriteUint64(z.Location[zgensym_f1f62b7068e7cc57_0].Offset)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.Location[zgensym_f1f62b7068e7cc57_0].Size)
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BlockData) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// array header, size 2
	o = append(o, 0x92)
	o, err = z.BlockMetadata.MarshalMsg(o) // not is.iface, gen/marshal.go:243
	if err != nil {
		return
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.Location)))
	for zgensym_f1f62b7068e7cc57_0 := range z.Location {
		// array header, size 2
		o = append(o, 0x92)
		o = msgp.AppendUint64(o, z.Location[zgensym_f1f62b7068e7cc57_0].Offset)
		o = msgp.AppendUint64(o, z.Location[zgensym_f1f62b7068e7cc57_0].Size)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BlockData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *BlockData) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zgensym_f1f62b7068e7cc57_4 uint32
	zgensym_f1f62b7068e7cc57_4, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_4 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_4}
		return
	}
	bts, err = z.BlockMetadata.UnmarshalMsg(bts)
	if err != nil {
		return
	}
	if nbs.AlwaysNil {
		(z.Location) = (z.Location)[:0]
	} else {

		var zgensym_f1f62b7068e7cc57_5 uint32
		zgensym_f1f62b7068e7cc57_5, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return
		}
		if cap(z.Location) >= int(zgensym_f1f62b7068e7cc57_5) {
			z.Location = (z.Location)[:zgensym_f1f62b7068e7cc57_5]
		} else {
			z.Location = make(LocationSlice, zgensym_f1f62b7068e7cc57_5)
		}
		for zgensym_f1f62b7068e7cc57_0 := range z.Location {
			var zgensym_f1f62b7068e7cc57_6 uint32
			zgensym_f1f62b7068e7cc57_6, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if zgensym_f1f62b7068e7cc57_6 != 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_6}
				return
			}
			z.Location[zgensym_f1f62b7068e7cc57_0].Offset, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
			z.Location[zgensym_f1f62b7068e7cc57_0].Size, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BlockData) Msgsize() (s int) {
	s = 1 + z.BlockMetadata.Msgsize() + msgp.ArrayHeaderSize + (len(z.Location) * (23 + msgp.Uint64Size + msgp.Uint64Size))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *LocationEntry) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_7 uint32
	zgensym_f1f62b7068e7cc57_7, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_7 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_7}
		return
	}
	z.Offset, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.Size, err = dc.ReadUint64()
	if err != nil {
		return
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z LocationEntry) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return err
	}
	err = en.WriteUint64(z.Offset)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Size)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z LocationEntry) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// array header, size 2
	o = append(o, 0x92)
	o = msgp.AppendUint64(o, z.Offset)
	o = msgp.AppendUint64(o, z.Size)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LocationEntry) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *LocationEntry) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zgensym_f1f62b7068e7cc57_8 uint32
	zgensym_f1f62b7068e7cc57_8, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_8 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_8}
		return
	}
	z.Offset, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.Size, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z LocationEntry) Msgsize() (s int) {
	s = 1 + msgp.Uint64Size + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *LocationSlice) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_11 uint32
	zgensym_f1f62b7068e7cc57_11, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap((*z)) >= int(zgensym_f1f62b7068e7cc57_11) {
		(*z) = (*z)[:zgensym_f1f62b7068e7cc57_11]
	} else {
		(*z) = make(LocationSlice, zgensym_f1f62b7068e7cc57_11)
	}
	for zgensym_f1f62b7068e7cc57_10 := range *z {
		var zgensym_f1f62b7068e7cc57_12 uint32
		zgensym_f1f62b7068e7cc57_12, err = dc.ReadArrayHeader()
		if err != nil {
			return
		}
		if zgensym_f1f62b7068e7cc57_12 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_12}
			return
		}
		(*z)[zgensym_f1f62b7068e7cc57_10].Offset, err = dc.ReadUint64()
		if err != nil {
			return
		}
		(*z)[zgensym_f1f62b7068e7cc57_10].Size, err = dc.ReadUint64()
		if err != nil {
			return
		}
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z LocationSlice) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		return
	}
	for zgensym_f1f62b7068e7cc57_13 := range z {
		// array header, size 2
		err = en.Append(0x92)
		if err != nil {
			return err
		}
		err = en.WriteUint64(z[zgensym_f1f62b7068e7cc57_13].Offset)
		if err != nil {
			return
		}
		err = en.WriteUint64(z[zgensym_f1f62b7068e7cc57_13].Size)
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z LocationSlice) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zgensym_f1f62b7068e7cc57_13 := range z {
		// array header, size 2
		o = append(o, 0x92)
		o = msgp.AppendUint64(o, z[zgensym_f1f62b7068e7cc57_13].Offset)
		o = msgp.AppendUint64(o, z[zgensym_f1f62b7068e7cc57_13].Size)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LocationSlice) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *LocationSlice) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	if nbs.AlwaysNil {
		(*z) = (*z)[:0]
	} else {

		var zgensym_f1f62b7068e7cc57_15 uint32
		zgensym_f1f62b7068e7cc57_15, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return
		}
		if cap((*z)) >= int(zgensym_f1f62b7068e7cc57_15) {
			(*z) = (*z)[:zgensym_f1f62b7068e7cc57_15]
		} else {
			(*z) = make(LocationSlice, zgensym_f1f62b7068e7cc57_15)
		}
		for zgensym_f1f62b7068e7cc57_14 := range *z {
			var zgensym_f1f62b7068e7cc57_16 uint32
			zgensym_f1f62b7068e7cc57_16, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if zgensym_f1f62b7068e7cc57_16 != 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_16}
				return
			}
			(*z)[zgensym_f1f62b7068e7cc57_14].Offset, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
			(*z)[zgensym_f1f62b7068e7cc57_14].Size, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z LocationSlice) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (len(z) * (23 + msgp.Uint64Size + msgp.Uint64Size))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OpEntry) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_18 uint32
	zgensym_f1f62b7068e7cc57_18, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_18 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_18}
		return
	}
	var zgensym_f1f62b7068e7cc57_19 uint32
	zgensym_f1f62b7068e7cc57_19, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_19 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_19}
		return
	}
	z.Location.Offset, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.Location.Size, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.Free, err = dc.ReadBool()
	if err != nil {
		return
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *OpEntry) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// array header, size 2
	// array header, size 2
	err = en.Append(0x92, 0x92)
	if err != nil {
		return err
	}
	err = en.WriteUint64(z.Location.Offset)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Location.Size)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Free)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OpEntry) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// array header, size 2
	// array header, size 2
	o = append(o, 0x92, 0x92)
	o = msgp.AppendUint64(o, z.Location.Offset)
	o = msgp.AppendUint64(o, z.Location.Size)
	o = msgp.AppendBool(o, z.Free)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OpEntry) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *OpEntry) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zgensym_f1f62b7068e7cc57_20 uint32
	zgensym_f1f62b7068e7cc57_20, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_20 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_20}
		return
	}
	var zgensym_f1f62b7068e7cc57_21 uint32
	zgensym_f1f62b7068e7cc57_21, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_21 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_21}
		return
	}
	z.Location.Offset, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.Location.Size, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.Free, bts, err = nbs.ReadBoolBytes(bts)

	if err != nil {
		return
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OpEntry) Msgsize() (s int) {
	s = 1 + 1 + msgp.Uint64Size + msgp.Uint64Size + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OpSlice) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_24 uint32
	zgensym_f1f62b7068e7cc57_24, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap((*z)) >= int(zgensym_f1f62b7068e7cc57_24) {
		(*z) = (*z)[:zgensym_f1f62b7068e7cc57_24]
	} else {
		(*z) = make(OpSlice, zgensym_f1f62b7068e7cc57_24)
	}
	for zgensym_f1f62b7068e7cc57_23 := range *z {
		err = (*z)[zgensym_f1f62b7068e7cc57_23].DecodeMsg(dc)
		if err != nil {
			return
		}
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z OpSlice) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		return
	}
	for zgensym_f1f62b7068e7cc57_25 := range z {
		// encodeGen.gBase IDENT

		// record the interface for deduplication
		var dup bool
		dup, err = en.DedupWriteIsDup(z[zgensym_f1f62b7068e7cc57_25])
		if err != nil {
			return
		}
		if !dup {
			err = z[zgensym_f1f62b7068e7cc57_25].EncodeMsg(en)
			if err != nil {
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z OpSlice) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zgensym_f1f62b7068e7cc57_25 := range z {
		o, err = z[zgensym_f1f62b7068e7cc57_25].MarshalMsg(o) // not is.iface, gen/marshal.go:243
		if err != nil {
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OpSlice) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *OpSlice) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	if nbs.AlwaysNil {
		(*z) = (*z)[:0]
	} else {

		var zgensym_f1f62b7068e7cc57_27 uint32
		zgensym_f1f62b7068e7cc57_27, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return
		}
		if cap((*z)) >= int(zgensym_f1f62b7068e7cc57_27) {
			(*z) = (*z)[:zgensym_f1f62b7068e7cc57_27]
		} else {
			(*z) = make(OpSlice, zgensym_f1f62b7068e7cc57_27)
		}
		for zgensym_f1f62b7068e7cc57_26 := range *z {
			bts, err = (*z)[zgensym_f1f62b7068e7cc57_26].UnmarshalMsg(bts)
			if err != nil {
				return
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z OpSlice) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zgensym_f1f62b7068e7cc57_28 := range z {
		s += z[zgensym_f1f62b7068e7cc57_28].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Superblock) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_32 uint32
	zgensym_f1f62b7068e7cc57_32, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_32 != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zgensym_f1f62b7068e7cc57_32}
		return
	}
	z.Generation, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.BytesUsed, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.BytesTotal, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zgensym_f1f62b7068e7cc57_33 uint32
	zgensym_f1f62b7068e7cc57_33, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.RootLocation) >= int(zgensym_f1f62b7068e7cc57_33) {
		z.RootLocation = (z.RootLocation)[:zgensym_f1f62b7068e7cc57_33]
	} else {
		z.RootLocation = make(LocationSlice, zgensym_f1f62b7068e7cc57_33)
	}
	for zgensym_f1f62b7068e7cc57_29 := range z.RootLocation {
		var zgensym_f1f62b7068e7cc57_34 uint32
		zgensym_f1f62b7068e7cc57_34, err = dc.ReadArrayHeader()
		if err != nil {
			return
		}
		if zgensym_f1f62b7068e7cc57_34 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_34}
			return
		}
		z.RootLocation[zgensym_f1f62b7068e7cc57_29].Offset, err = dc.ReadUint64()
		if err != nil {
			return
		}
		z.RootLocation[zgensym_f1f62b7068e7cc57_29].Size, err = dc.ReadUint64()
		if err != nil {
			return
		}
	}
	var zgensym_f1f62b7068e7cc57_35 uint32
	zgensym_f1f62b7068e7cc57_35, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Pending) >= int(zgensym_f1f62b7068e7cc57_35) {
		z.Pending = (z.Pending)[:zgensym_f1f62b7068e7cc57_35]
	} else {
		z.Pending = make(OpSlice, zgensym_f1f62b7068e7cc57_35)
	}
	for zgensym_f1f62b7068e7cc57_30 := range z.Pending {
		err = z.Pending[zgensym_f1f62b7068e7cc57_30].DecodeMsg(dc)
		if err != nil {
			return
		}
	}
	var zgensym_f1f62b7068e7cc57_36 uint32
	zgensym_f1f62b7068e7cc57_36, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.PendingLocation) >= int(zgensym_f1f62b7068e7cc57_36) {
		z.PendingLocation = (z.PendingLocation)[:zgensym_f1f62b7068e7cc57_36]
	} else {
		z.PendingLocation = make(LocationSlice, zgensym_f1f62b7068e7cc57_36)
	}
	for zgensym_f1f62b7068e7cc57_31 := range z.PendingLocation {
		var zgensym_f1f62b7068e7cc57_37 uint32
		zgensym_f1f62b7068e7cc57_37, err = dc.ReadArrayHeader()
		if err != nil {
			return
		}
		if zgensym_f1f62b7068e7cc57_37 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_37}
			return
		}
		z.PendingLocation[zgensym_f1f62b7068e7cc57_31].Offset, err = dc.ReadUint64()
		if err != nil {
			return
		}
		z.PendingLocation[zgensym_f1f62b7068e7cc57_31].Size, err = dc.ReadUint64()
		if err != nil {
			return
		}
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *Superblock) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// array header, size 6
	err = en.Append(0x96)
	if err != nil {
		return err
	}
	err = en.WriteUint64(z.Generation)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesUsed)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesTotal)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.RootLocation)))
	if err != nil {
		return
	}
	for zgensym_f1f62b7068e7cc57_29 := range z.RootLocation {
		// array header, size 2
		err = en.Append(0x92)
		if err != nil {
			return err
		}
		err = en.WriteUint64(z.RootLocation[zgensym_f1f62b7068e7cc57_29].Offset)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.RootLocation[zgensym_f1f62b7068e7cc57_29].Size)
		if err != nil {
			return
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.Pending)))
	if err != nil {
		return
	}
	for zgensym_f1f62b7068e7cc57_30 := range z.Pending {
		// encodeGen.gBase IDENT

		// record the interface for deduplication
		var dup bool
		dup, err = en.DedupWriteIsDup(z.Pending[zgensym_f1f62b7068e7cc57_30])
		if err != nil {
			return
		}
		if !dup {
			err = z.Pending[zgensym_f1f62b7068e7cc57_30].EncodeMsg(en)
			if err != nil {
				return
			}
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.PendingLocation)))
	if err != nil {
		return
	}
	for zgensym_f1f62b7068e7cc57_31 := range z.PendingLocation {
		// array header, size 2
		err = en.Append(0x92)
		if err != nil {
			return err
		}
		err = en.WriteUint64(z.PendingLocation[zgensym_f1f62b7068e7cc57_31].Offset)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.PendingLocation[zgensym_f1f62b7068e7cc57_31].Size)
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Superblock) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// array header, size 6
	o = append(o, 0x96)
	o = msgp.AppendUint64(o, z.Generation)
	o = msgp.AppendUint64(o, z.BytesUsed)
	o = msgp.AppendUint64(o, z.BytesTotal)
	o = msgp.AppendArrayHeader(o, uint32(len(z.RootLocation)))
	for zgensym_f1f62b7068e7cc57_29 := range z.RootLocation {
		// array header, size 2
		o = append(o, 0x92)
		o = msgp.AppendUint64(o, z.RootLocation[zgensym_f1f62b7068e7cc57_29].Offset)
		o = msgp.AppendUint64(o, z.RootLocation[zgensym_f1f62b7068e7cc57_29].Size)
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.Pending)))
	for zgensym_f1f62b7068e7cc57_30 := range z.Pending {
		o, err = z.Pending[zgensym_f1f62b7068e7cc57_30].MarshalMsg(o) // not is.iface, gen/marshal.go:243
		if err != nil {
			return
		}
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.PendingLocation)))
	for zgensym_f1f62b7068e7cc57_31 := range z.PendingLocation {
		// array header, size 2
		o = append(o, 0x92)
		o = msgp.AppendUint64(o, z.PendingLocation[zgensym_f1f62b7068e7cc57_31].Offset)
		o = msgp.AppendUint64(o, z.PendingLocation[zgensym_f1f62b7068e7cc57_31].Size)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Superblock) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Superblock) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zgensym_f1f62b7068e7cc57_38 uint32
	zgensym_f1f62b7068e7cc57_38, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_38 != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zgensym_f1f62b7068e7cc57_38}
		return
	}
	z.Generation, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.BytesUsed, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.BytesTotal, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	if nbs.AlwaysNil {
		(z.RootLocation) = (z.RootLocation)[:0]
	} else {

		var zgensym_f1f62b7068e7cc57_39 uint32
		zgensym_f1f62b7068e7cc57_39, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return
		}
		if cap(z.RootLocation) >= int(zgensym_f1f62b7068e7cc57_39) {
			z.RootLocation = (z.RootLocation)[:zgensym_f1f62b7068e7cc57_39]
		} else {
			z.RootLocation = make(LocationSlice, zgensym_f1f62b7068e7cc57_39)
		}
		for zgensym_f1f62b7068e7cc57_29 := range z.RootLocation {
			var zgensym_f1f62b7068e7cc57_40 uint32
			zgensym_f1f62b7068e7cc57_40, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if zgensym_f1f62b7068e7cc57_40 != 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_40}
				return
			}
			z.RootLocation[zgensym_f1f62b7068e7cc57_29].Offset, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
			z.RootLocation[zgensym_f1f62b7068e7cc57_29].Size, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
		}
	}
	if nbs.AlwaysNil {
		(z.Pending) = (z.Pending)[:0]
	} else {

		var zgensym_f1f62b7068e7cc57_41 uint32
		zgensym_f1f62b7068e7cc57_41, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return
		}
		if cap(z.Pending) >= int(zgensym_f1f62b7068e7cc57_41) {
			z.Pending = (z.Pending)[:zgensym_f1f62b7068e7cc57_41]
		} else {
			z.Pending = make(OpSlice, zgensym_f1f62b7068e7cc57_41)
		}
		for zgensym_f1f62b7068e7cc57_30 := range z.Pending {
			bts, err = z.Pending[zgensym_f1f62b7068e7cc57_30].UnmarshalMsg(bts)
			if err != nil {
				return
			}
		}
	}
	if nbs.AlwaysNil {
		(z.PendingLocation) = (z.PendingLocation)[:0]
	} else {

		var zgensym_f1f62b7068e7cc57_42 uint32
		zgensym_f1f62b7068e7cc57_42, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return
		}
		if cap(z.PendingLocation) >= int(zgensym_f1f62b7068e7cc57_42) {
			z.PendingLocation = (z.PendingLocation)[:zgensym_f1f62b7068e7cc57_42]
		} else {
			z.PendingLocation = make(LocationSlice, zgensym_f1f62b7068e7cc57_42)
		}
		for zgensym_f1f62b7068e7cc57_31 := range z.PendingLocation {
			var zgensym_f1f62b7068e7cc57_43 uint32
			zgensym_f1f62b7068e7cc57_43, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if zgensym_f1f62b7068e7cc57_43 != 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_43}
				return
			}
			z.PendingLocation[zgensym_f1f62b7068e7cc57_31].Offset, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
			z.PendingLocation[zgensym_f1f62b7068e7cc57_31].Size, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Superblock) Msgsize() (s int) {
	s = 1 + msgp.Uint64Size + msgp.Uint64Size + msgp.Uint64Size + msgp.ArrayHeaderSize + (len(z.RootLocation) * (23 + msgp.Uint64Size + msgp.Uint64Size)) + msgp.ArrayHeaderSize
	for zgensym_f1f62b7068e7cc57_30 := range z.Pending {
		s += z.Pending[zgensym_f1f62b7068e7cc57_30].Msgsize()
	}
	s += msgp.ArrayHeaderSize + (len(z.PendingLocation) * (23 + msgp.Uint64Size + msgp.Uint64Size))
	return
}
