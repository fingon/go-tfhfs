// Code generated by GREENPACK (github.com/glycerine/greenpack). DO NOT EDIT.

package tree

import (
	"github.com/glycerine/greenpack/msgp"
)

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *BlockData) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_1 uint32
	zgensym_f1f62b7068e7cc57_1, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_1 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_1}
		return
	}
	err = z.BlockMetadata.DecodeMsg(dc)
	if err != nil {
		return
	}
	var zgensym_f1f62b7068e7cc57_2 uint32
	zgensym_f1f62b7068e7cc57_2, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Location) >= int(zgensym_f1f62b7068e7cc57_2) {
		z.Location = (z.Location)[:zgensym_f1f62b7068e7cc57_2]
	} else {
		z.Location = make(LocationSlice, zgensym_f1f62b7068e7cc57_2)
	}
	for zgensym_f1f62b7068e7cc57_0 := range z.Location {
		var zgensym_f1f62b7068e7cc57_3 uint32
		zgensym_f1f62b7068e7cc57_3, err = dc.ReadArrayHeader()
		if err != nil {
			return
		}
		if zgensym_f1f62b7068e7cc57_3 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_3}
			return
		}
		z.Location[zgensym_f1f62b7068e7cc57_0].Offset, err = dc.ReadUint64()
		if err != nil {
			return
		}
		z.Location[zgensym_f1f62b7068e7cc57_0].Size, err = dc.ReadUint64()
		if err != nil {
			return
		}
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *BlockData) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return err
	}
	// encodeGen.gBase IDENT

	// record the interface for deduplication
	var dup bool
	dup, err = en.DedupWriteIsDup(z.BlockMetadata)
	if err != nil {
		return
	}
	if !dup {
		err = z.BlockMetadata.EncodeMsg(en)
		if err != nil {
			return
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.Location)))
	if err != nil {
		return
	}
	for zgensym_f1f62b7068e7cc57_0 := range z.Location {
		// array header, size 2
		err = en.Append(0x92)
		if err != nil {
			return err
		}
		err = en.WriteUint64(z.Location[zgensym_f1f62b7068e7cc57_0].Offset)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.Location[zgensym_f1f62b7068e7cc57_0].Size)
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BlockData) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// array header, size 2
	o = append(o, 0x92)
	o, err = z.BlockMetadata.MarshalMsg(o) // not is.iface, gen/marshal.go:243
	if err != nil {
		return
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.Location)))
	for zgensym_f1f62b7068e7cc57_0 := range z.Location {
		// array header, size 2
		o = append(o, 0x92)
		o = msgp.AppendUint64(o, z.Location[zgensym_f1f62b7068e7cc57_0].Offset)
		o = msgp.AppendUint64(o, z.Location[zgensym_f1f62b7068e7cc57_0].Size)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BlockData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *BlockData) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zgensym_f1f62b7068e7cc57_4 uint32
	zgensym_f1f62b7068e7cc57_4, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_4 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_4}
		return
	}
	bts, err = z.BlockMetadata.UnmarshalMsg(bts)
	if err != nil {
		return
	}
	if nbs.AlwaysNil {
		(z.Location) = (z.Location)[:0]
	} else {

		var zgensym_f1f62b7068e7cc57_5 uint32
		zgensym_f1f62b7068e7cc57_5, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return
		}
		if cap(z.Location) >= int(zgensym_f1f62b7068e7cc57_5) {
			z.Location = (z.Location)[:zgensym_f1f62b7068e7cc57_5]
		} else {
			z.Location = make(LocationSlice, zgensym_f1f62b7068e7cc57_5)
		}
		for zgensym_f1f62b7068e7cc57_0 := range z.Location {
			var zgensym_f1f62b7068e7cc57_6 uint32
			zgensym_f1f62b7068e7cc57_6, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if zgensym_f1f62b7068e7cc57_6 != 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_6}
				return
			}
			z.Location[zgensym_f1f62b7068e7cc57_0].Offset, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
			z.Location[zgensym_f1f62b7068e7cc57_0].Size, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BlockData) Msgsize() (s int) {
	s = 1 + z.BlockMetadata.Msgsize() + msgp.ArrayHeaderSize + (len(z.Location) * (23 + msgp.Uint64Size + msgp.Uint64Size))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *LocationEntry) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_7 uint32
	zgensym_f1f62b7068e7cc57_7, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_7 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_7}
		return
	}
	z.Offset, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.Size, err = dc.ReadUint64()
	if err != nil {
		return
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z LocationEntry) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return err
	}
	err = en.WriteUint64(z.Offset)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Size)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z LocationEntry) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// array header, size 2
	o = append(o, 0x92)
	o = msgp.AppendUint64(o, z.Offset)
	o = msgp.AppendUint64(o, z.Size)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LocationEntry) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *LocationEntry) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zgensym_f1f62b7068e7cc57_8 uint32
	zgensym_f1f62b7068e7cc57_8, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_8 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_8}
		return
	}
	z.Offset, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.Size, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z LocationEntry) Msgsize() (s int) {
	s = 1 + msgp.Uint64Size + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *LocationSlice) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_11 uint32
	zgensym_f1f62b7068e7cc57_11, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap((*z)) >= int(zgensym_f1f62b7068e7cc57_11) {
		(*z) = (*z)[:zgensym_f1f62b7068e7cc57_11]
	} else {
		(*z) = make(LocationSlice, zgensym_f1f62b7068e7cc57_11)
	}
	for zgensym_f1f62b7068e7cc57_10 := range *z {
		var zgensym_f1f62b7068e7cc57_12 uint32
		zgensym_f1f62b7068e7cc57_12, err = dc.ReadArrayHeader()
		if err != nil {
			return
		}
		if zgensym_f1f62b7068e7cc57_12 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_12}
			return
		}
		(*z)[zgensym_f1f62b7068e7cc57_10].Offset, err = dc.ReadUint64()
		if err != nil {
			return
		}
		(*z)[zgensym_f1f62b7068e7cc57_10].Size, err = dc.ReadUint64()
		if err != nil {
			return
		}
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z LocationSlice) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		return
	}
	for zgensym_f1f62b7068e7cc57_13 := range z {
		// array header, size 2
		err = en.Append(0x92)
		if err != nil {
			return err
		}
		err = en.WriteUint64(z[zgensym_f1f62b7068e7cc57_13].Offset)
		if err != nil {
			return
		}
		err = en.WriteUint64(z[zgensym_f1f62b7068e7cc57_13].Size)
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z LocationSlice) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zgensym_f1f62b7068e7cc57_13 := range z {
		// array header, size 2
		o = append(o, 0x92)
		o = msgp.AppendUint64(o, z[zgensym_f1f62b7068e7cc57_13].Offset)
		o = msgp.AppendUint64(o, z[zgensym_f1f62b7068e7cc57_13].Size)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LocationSlice) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *LocationSlice) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	if nbs.AlwaysNil {
		(*z) = (*z)[:0]
	} else {

		var zgensym_f1f62b7068e7cc57_15 uint32
		zgensym_f1f62b7068e7cc57_15, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return
		}
		if cap((*z)) >= int(zgensym_f1f62b7068e7cc57_15) {
			(*z) = (*z)[:zgensym_f1f62b7068e7cc57_15]
		} else {
			(*z) = make(LocationSlice, zgensym_f1f62b7068e7cc57_15)
		}
		for zgensym_f1f62b7068e7cc57_14 := range *z {
			var zgensym_f1f62b7068e7cc57_16 uint32
			zgensym_f1f62b7068e7cc57_16, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if zgensym_f1f62b7068e7cc57_16 != 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_16}
				return
			}
			(*z)[zgensym_f1f62b7068e7cc57_14].Offset, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
			(*z)[zgensym_f1f62b7068e7cc57_14].Size, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z LocationSlice) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (len(z) * (23 + msgp.Uint64Size + msgp.Uint64Size))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OpEntry) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_18 uint32
	zgensym_f1f62b7068e7cc57_18, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_18 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_18}
		return
	}
	var zgensym_f1f62b7068e7cc57_19 uint32
	zgensym_f1f62b7068e7cc57_19, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_19 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_19}
		return
	}
	z.Location.Offset, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.Location.Size, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.Free, err = dc.ReadBool()
	if err != nil {
		return
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *OpEntry) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// array header, size 2
	// array header, size 2
	err = en.Append(0x92, 0x92)
	if err != nil {
		return err
	}
	err = en.WriteUint64(z.Location.Offset)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Location.Size)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Free)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OpEntry) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// array header, size 2
	// array header, size 2
	o = append(o, 0x92, 0x92)
	o = msgp.AppendUint64(o, z.Location.Offset)
	o = msgp.AppendUint64(o, z.Location.Size)
	o = msgp.AppendBool(o, z.Free)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OpEntry) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *OpEntry) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zgensym_f1f62b7068e7cc57_20 uint32
	zgensym_f1f62b7068e7cc57_20, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_20 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_20}
		return
	}
	var zgensym_f1f62b7068e7cc57_21 uint32
	zgensym_f1f62b7068e7cc57_21, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_21 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_21}
		return
	}
	z.Location.Offset, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.Location.Size, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.Free, bts, err = nbs.ReadBoolBytes(bts)

	if err != nil {
		return
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OpEntry) Msgsize() (s int) {
	s = 1 + 1 + msgp.Uint64Size + msgp.Uint64Size + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *OpSlice) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_24 uint32
	zgensym_f1f62b7068e7cc57_24, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap((*z)) >= int(zgensym_f1f62b7068e7cc57_24) {
		(*z) = (*z)[:zgensym_f1f62b7068e7cc57_24]
	} else {
		(*z) = make(OpSlice, zgensym_f1f62b7068e7cc57_24)
	}
	for zgensym_f1f62b7068e7cc57_23 := range *z {
		var zgensym_f1f62b7068e7cc57_25 uint32
		zgensym_f1f62b7068e7cc57_25, err = dc.ReadArrayHeader()
		if err != nil {
			return
		}
		if zgensym_f1f62b7068e7cc57_25 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_25}
			return
		}
		var zgensym_f1f62b7068e7cc57_26 uint32
		zgensym_f1f62b7068e7cc57_26, err = dc.ReadArrayHeader()
		if err != nil {
			return
		}
		if zgensym_f1f62b7068e7cc57_26 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_26}
			return
		}
		(*z)[zgensym_f1f62b7068e7cc57_23].Location.Offset, err = dc.ReadUint64()
		if err != nil {
			return
		}
		(*z)[zgensym_f1f62b7068e7cc57_23].Location.Size, err = dc.ReadUint64()
		if err != nil {
			return
		}
		(*z)[zgensym_f1f62b7068e7cc57_23].Free, err = dc.ReadBool()
		if err != nil {
			return
		}
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z OpSlice) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	err = en.WriteArrayHeader(uint32(len(z)))
	if err != nil {
		return
	}
	for zgensym_f1f62b7068e7cc57_27 := range z {
		// array header, size 2
		// array header, size 2
		err = en.Append(0x92, 0x92)
		if err != nil {
			return err
		}
		err = en.WriteUint64(z[zgensym_f1f62b7068e7cc57_27].Location.Offset)
		if err != nil {
			return
		}
		err = en.WriteUint64(z[zgensym_f1f62b7068e7cc57_27].Location.Size)
		if err != nil {
			return
		}
		err = en.WriteBool(z[zgensym_f1f62b7068e7cc57_27].Free)
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z OpSlice) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for zgensym_f1f62b7068e7cc57_27 := range z {
		// array header, size 2
		// array header, size 2
		o = append(o, 0x92, 0x92)
		o = msgp.AppendUint64(o, z[zgensym_f1f62b7068e7cc57_27].Location.Offset)
		o = msgp.AppendUint64(o, z[zgensym_f1f62b7068e7cc57_27].Location.Size)
		o = msgp.AppendBool(o, z[zgensym_f1f62b7068e7cc57_27].Free)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OpSlice) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *OpSlice) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	if nbs.AlwaysNil {
		(*z) = (*z)[:0]
	} else {

		var zgensym_f1f62b7068e7cc57_29 uint32
		zgensym_f1f62b7068e7cc57_29, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return
		}
		if cap((*z)) >= int(zgensym_f1f62b7068e7cc57_29) {
			(*z) = (*z)[:zgensym_f1f62b7068e7cc57_29]
		} else {
			(*z) = make(OpSlice, zgensym_f1f62b7068e7cc57_29)
		}
		for zgensym_f1f62b7068e7cc57_28 := range *z {
			var zgensym_f1f62b7068e7cc57_30 uint32
			zgensym_f1f62b7068e7cc57_30, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if zgensym_f1f62b7068e7cc57_30 != 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_30}
				return
			}
			var zgensym_f1f62b7068e7cc57_31 uint32
			zgensym_f1f62b7068e7cc57_31, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if zgensym_f1f62b7068e7cc57_31 != 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_31}
				return
			}
			(*z)[zgensym_f1f62b7068e7cc57_28].Location.Offset, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
			(*z)[zgensym_f1f62b7068e7cc57_28].Location.Size, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
			(*z)[zgensym_f1f62b7068e7cc57_28].Free, bts, err = nbs.ReadBoolBytes(bts)

			if err != nil {
				return
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z OpSlice) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (len(z) * (25 + 23 + msgp.Uint64Size + msgp.Uint64Size + msgp.BoolSize))
	return
}

// DecodeMsg implements msgp.Decodable
// We treat empty fields as if we read a Nil from the wire.
func (z *Superblock) DecodeMsg(dc *msgp.Reader) (err error) {

	var zgensym_f1f62b7068e7cc57_35 uint32
	zgensym_f1f62b7068e7cc57_35, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_35 != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zgensym_f1f62b7068e7cc57_35}
		return
	}
	z.Generation, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.BytesUsed, err = dc.ReadUint64()
	if err != nil {
		return
	}
	z.BytesTotal, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zgensym_f1f62b7068e7cc57_36 uint32
	zgensym_f1f62b7068e7cc57_36, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.RootLocation) >= int(zgensym_f1f62b7068e7cc57_36) {
		z.RootLocation = (z.RootLocation)[:zgensym_f1f62b7068e7cc57_36]
	} else {
		z.RootLocation = make(LocationSlice, zgensym_f1f62b7068e7cc57_36)
	}
	for zgensym_f1f62b7068e7cc57_33 := range z.RootLocation {
		var zgensym_f1f62b7068e7cc57_37 uint32
		zgensym_f1f62b7068e7cc57_37, err = dc.ReadArrayHeader()
		if err != nil {
			return
		}
		if zgensym_f1f62b7068e7cc57_37 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_37}
			return
		}
		z.RootLocation[zgensym_f1f62b7068e7cc57_33].Offset, err = dc.ReadUint64()
		if err != nil {
			return
		}
		z.RootLocation[zgensym_f1f62b7068e7cc57_33].Size, err = dc.ReadUint64()
		if err != nil {
			return
		}
	}
	err = z.Pending.DecodeMsg(dc)
	if err != nil {
		return
	}
	var zgensym_f1f62b7068e7cc57_38 uint32
	zgensym_f1f62b7068e7cc57_38, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.PendingLocation) >= int(zgensym_f1f62b7068e7cc57_38) {
		z.PendingLocation = (z.PendingLocation)[:zgensym_f1f62b7068e7cc57_38]
	} else {
		z.PendingLocation = make(LocationSlice, zgensym_f1f62b7068e7cc57_38)
	}
	for zgensym_f1f62b7068e7cc57_34 := range z.PendingLocation {
		var zgensym_f1f62b7068e7cc57_39 uint32
		zgensym_f1f62b7068e7cc57_39, err = dc.ReadArrayHeader()
		if err != nil {
			return
		}
		if zgensym_f1f62b7068e7cc57_39 != 2 {
			err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_39}
			return
		}
		z.PendingLocation[zgensym_f1f62b7068e7cc57_34].Offset, err = dc.ReadUint64()
		if err != nil {
			return
		}
		z.PendingLocation[zgensym_f1f62b7068e7cc57_34].Size, err = dc.ReadUint64()
		if err != nil {
			return
		}
	}
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *Superblock) EncodeMsg(en *msgp.Writer) (err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	// array header, size 6
	err = en.Append(0x96)
	if err != nil {
		return err
	}
	err = en.WriteUint64(z.Generation)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesUsed)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesTotal)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.RootLocation)))
	if err != nil {
		return
	}
	for zgensym_f1f62b7068e7cc57_33 := range z.RootLocation {
		// array header, size 2
		err = en.Append(0x92)
		if err != nil {
			return err
		}
		err = en.WriteUint64(z.RootLocation[zgensym_f1f62b7068e7cc57_33].Offset)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.RootLocation[zgensym_f1f62b7068e7cc57_33].Size)
		if err != nil {
			return
		}
	}
	// encodeGen.gBase IDENT

	// record the interface for deduplication
	var dup bool
	dup, err = en.DedupWriteIsDup(z.Pending)
	if err != nil {
		return
	}
	if !dup {
		err = z.Pending.EncodeMsg(en)
		if err != nil {
			return
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.PendingLocation)))
	if err != nil {
		return
	}
	for zgensym_f1f62b7068e7cc57_34 := range z.PendingLocation {
		// array header, size 2
		err = en.Append(0x92)
		if err != nil {
			return err
		}
		err = en.WriteUint64(z.PendingLocation[zgensym_f1f62b7068e7cc57_34].Offset)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.PendingLocation[zgensym_f1f62b7068e7cc57_34].Size)
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Superblock) MarshalMsg(b []byte) (o []byte, err error) {
	if p, ok := interface{}(z).(msgp.PreSave); ok {
		p.PreSaveHook()
	}

	o = msgp.Require(b, z.Msgsize())
	// array header, size 6
	o = append(o, 0x96)
	o = msgp.AppendUint64(o, z.Generation)
	o = msgp.AppendUint64(o, z.BytesUsed)
	o = msgp.AppendUint64(o, z.BytesTotal)
	o = msgp.AppendArrayHeader(o, uint32(len(z.RootLocation)))
	for zgensym_f1f62b7068e7cc57_33 := range z.RootLocation {
		// array header, size 2
		o = append(o, 0x92)
		o = msgp.AppendUint64(o, z.RootLocation[zgensym_f1f62b7068e7cc57_33].Offset)
		o = msgp.AppendUint64(o, z.RootLocation[zgensym_f1f62b7068e7cc57_33].Size)
	}
	o, err = z.Pending.MarshalMsg(o) // not is.iface, gen/marshal.go:243
	if err != nil {
		return
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.PendingLocation)))
	for zgensym_f1f62b7068e7cc57_34 := range z.PendingLocation {
		// array header, size 2
		o = append(o, 0x92)
		o = msgp.AppendUint64(o, z.PendingLocation[zgensym_f1f62b7068e7cc57_34].Offset)
		o = msgp.AppendUint64(o, z.PendingLocation[zgensym_f1f62b7068e7cc57_34].Size)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Superblock) UnmarshalMsg(bts []byte) (o []byte, err error) {
	return z.UnmarshalMsgWithCfg(bts, nil)
}
func (z *Superblock) UnmarshalMsgWithCfg(bts []byte, cfg *msgp.RuntimeConfig) (o []byte, err error) {
	var nbs msgp.NilBitsStack
	nbs.Init(cfg)
	var sawTopNil bool
	if msgp.IsNil(bts) {
		sawTopNil = true
		bts = nbs.PushAlwaysNil(bts[1:])
	}

	var zgensym_f1f62b7068e7cc57_40 uint32
	zgensym_f1f62b7068e7cc57_40, bts, err = nbs.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zgensym_f1f62b7068e7cc57_40 != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zgensym_f1f62b7068e7cc57_40}
		return
	}
	z.Generation, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.BytesUsed, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	z.BytesTotal, bts, err = nbs.ReadUint64Bytes(bts)

	if err != nil {
		return
	}
	if nbs.AlwaysNil {
		(z.RootLocation) = (z.RootLocation)[:0]
	} else {

		var zgensym_f1f62b7068e7cc57_41 uint32
		zgensym_f1f62b7068e7cc57_41, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return
		}
		if cap(z.RootLocation) >= int(zgensym_f1f62b7068e7cc57_41) {
			z.RootLocation = (z.RootLocation)[:zgensym_f1f62b7068e7cc57_41]
		} else {
			z.RootLocation = make(LocationSlice, zgensym_f1f62b7068e7cc57_41)
		}
		for zgensym_f1f62b7068e7cc57_33 := range z.RootLocation {
			var zgensym_f1f62b7068e7cc57_42 uint32
			zgensym_f1f62b7068e7cc57_42, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if zgensym_f1f62b7068e7cc57_42 != 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_42}
				return
			}
			z.RootLocation[zgensym_f1f62b7068e7cc57_33].Offset, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
			z.RootLocation[zgensym_f1f62b7068e7cc57_33].Size, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
		}
	}
	bts, err = z.Pending.UnmarshalMsg(bts)
	if err != nil {
		return
	}
	if nbs.AlwaysNil {
		(z.PendingLocation) = (z.PendingLocation)[:0]
	} else {

		var zgensym_f1f62b7068e7cc57_43 uint32
		zgensym_f1f62b7068e7cc57_43, bts, err = nbs.ReadArrayHeaderBytes(bts)
		if err != nil {
			return
		}
		if cap(z.PendingLocation) >= int(zgensym_f1f62b7068e7cc57_43) {
			z.PendingLocation = (z.PendingLocation)[:zgensym_f1f62b7068e7cc57_43]
		} else {
			z.PendingLocation = make(LocationSlice, zgensym_f1f62b7068e7cc57_43)
		}
		for zgensym_f1f62b7068e7cc57_34 := range z.PendingLocation {
			var zgensym_f1f62b7068e7cc57_44 uint32
			zgensym_f1f62b7068e7cc57_44, bts, err = nbs.ReadArrayHeaderBytes(bts)
			if err != nil {
				return
			}
			if zgensym_f1f62b7068e7cc57_44 != 2 {
				err = msgp.ArrayError{Wanted: 2, Got: zgensym_f1f62b7068e7cc57_44}
				return
			}
			z.PendingLocation[zgensym_f1f62b7068e7cc57_34].Offset, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
			z.PendingLocation[zgensym_f1f62b7068e7cc57_34].Size, bts, err = nbs.ReadUint64Bytes(bts)

			if err != nil {
				return
			}
		}
	}
	if sawTopNil {
		bts = nbs.PopAlwaysNil()
	}
	o = bts
	if p, ok := interface{}(z).(msgp.PostLoad); ok {
		p.PostLoadHook()
	}

	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Superblock) Msgsize() (s int) {
	s = 1 + msgp.Uint64Size + msgp.Uint64Size + msgp.Uint64Size + msgp.ArrayHeaderSize + (len(z.RootLocation) * (23 + msgp.Uint64Size + msgp.Uint64Size)) + z.Pending.Msgsize() + msgp.ArrayHeaderSize + (len(z.PendingLocation) * (23 + msgp.Uint64Size + msgp.Uint64Size))
	return
}
